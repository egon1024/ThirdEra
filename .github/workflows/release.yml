name: Release

on:
  pull_request:
    types: [closed]

permissions:
  contents: write

jobs:
  release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.merge_commit_sha }}

      - name: Create release
        id: create_release
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const body = pr.body || '';

            // Scan for bump directive at the beginning of a line
            // (same logic as version-preview workflow)
            let bumpType = null;
            for (const line of body.split('\n')) {
              const trimmed = line.trim().toLowerCase();
              if (trimmed.startsWith('#major')) { bumpType = 'major'; break; }
              if (trimmed.startsWith('#minor')) { bumpType = 'minor'; break; }
              if (trimmed.startsWith('#patch')) { bumpType = 'patch'; break; }
            }
            if (!bumpType) bumpType = 'minor';

            // Get the latest release to determine current version
            let currentVersion = '0.0.0';
            try {
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 1
              });
              if (releases.length > 0) {
                currentVersion = releases[0].tag_name.replace(/^v/, '');
              }
            } catch (e) {
              core.info(`No releases found, defaulting to ${currentVersion}`);
            }

            // Calculate next version using semver
            const parts = currentVersion.split('.').map(Number);
            let [major, minor, patch] = parts;
            if (bumpType === 'major') { major++; minor = 0; patch = 0; }
            else if (bumpType === 'minor') { minor++; patch = 0; }
            else if (bumpType === 'patch') { patch++; }
            const nextVersion = `${major}.${minor}.${patch}`;
            core.setOutput('next_version', nextVersion);

            // Build release notes
            const prUrl = pr.html_url;
            const prTitle = pr.title;
            const prNumber = pr.number;
            const prAuthor = pr.user.login;

            const releaseBody = [
              `## What's Changed`,
              '',
              `* ${prTitle} (#${prNumber}) by @${prAuthor}`,
              '',
              `**PR:** ${prUrl}`,
              '',
              `---`,
              '',
              `| | Version |`,
              `|---|---|`,
              `| **Previous** | \`${currentVersion}\` |`,
              `| **This Release** | \`${nextVersion}\` |`,
              `| **Bump Type** | \`${bumpType}\` |`,
            ].join('\n');

            // Create the release and tag
            const { data: release } = await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: nextVersion,
              target_commitish: pr.merge_commit_sha,
              name: `v${nextVersion}`,
              body: releaseBody,
              draft: false,
              prerelease: false
            });

            core.info(`Release created: ${release.html_url}`);
            
            // Output the release ID for the next step
            core.setOutput('release_id', release.id);

      - name: Upload system.json as release asset
        uses: actions/github-script@v7
        env:
          RELEASE_ID: ${{ steps.create_release.outputs.release_id }}
          NEXT_VERSION: ${{ steps.create_release.outputs.next_version }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            const systemJsonPath = path.join(process.cwd(), 'system.json');
            const manifest = JSON.parse(fs.readFileSync(systemJsonPath, 'utf8'));
            manifest.version = process.env.NEXT_VERSION;
            manifest.download = `https://github.com/${context.repo.owner}/${context.repo.repo}/archive/refs/tags/${process.env.NEXT_VERSION}.zip`;
            const systemJsonContent = JSON.stringify(manifest, null, 2);
            
            await github.rest.repos.uploadReleaseAsset({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: process.env.RELEASE_ID,
              name: 'system.json',
              data: systemJsonContent,
              headers: {
                'content-type': 'application/json'
              }
            });
            
            core.info('system.json uploaded as release asset');